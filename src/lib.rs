//! Generate type schemas for Rust types.
//!
//! Schematic is a framework for describing the structure and contents of Rust
//! types efficiently and generically. It seeks to extend [Serde] with the ability
//! to generate schemas for the data generated by Serde.
//!
//! # Data Model
//!
//! Schematic's data model defines how it describes Rust types. This data model
//! represents subset of the full Rust type system, supporting only the parts of the
//! type system that can be represented in data. The data model is specifically
//! designed to extend the [Serde data model][sdm], such that any type that can be
//! serialized by Serde can also be described fully by Schematic.
//!
//! ## Types
//!
//! * **16 primitive types**
//!   * `bool`
//!   * `i8`, `i16`, `i32`, `i64`, `isize`
//!   * `u8`, `u16`, `u32`, `u64`, `usize`
//!   * `f32`, `f64`
//!   * `char`
//! * **2 string types**
//!   * `str` representing `&str`.
//!   * `String` representing all user-defined string types, including `String`, and
//!     `Box<str>`.
//! * `unit` representing `()`.
//! * `option`, representing `Option<T>` and any other optional types.
//! * **Array types**
//!   * `array`, i.e. `[T; len]`
//!   * `slice`, i.e. `&[T]`
//!   * `seq` representing all user-defined array types, including `Vec<T>` and
//!     `Box<[T]>`.
//! * `tuple` representing anonymous tuple types.
//! * `map` representing user-defined map types such as `HashMap<K, V>` and
//!   `BTreeMap<K, V>`.
//! * **Struct types**
//!   * `unit_struct` for unit-like structs.
//!   * `struct` for structs with named fields.
//!   * `tuple_struct` for structs with unnamed fields.
//!   * `newtype_struct` for tuple-like structs with a single field.
//! * `enum` representing user-defined enums. Each enum in turn contains zero or
//!   more variants:
//!   * `unit_variant` for unit-like variants.
//!   * `struct_variant` for variants with named fields.
//!   * `tuple_variant` for variants with unnamed fields.
//!
//! [Serde]: https://crates.io/crates/serde

use serde::{Deserialize, Serialize};
use std::borrow::Cow;

mod describe;
mod primitive;
mod schema;
mod schema_describer;

pub use crate::{describe::*, schema::*, schema_describer::*};

/// Describes `T` into an in-memory representation of the type tree.
pub fn describe<T: Describe>() -> Schema {
    let mut describe = SchemaDescriber;

    // NOTE: The unwrap here will never panic because the error type of
    // `SchemaDescriber` is `!`.
    T::describe(&mut describe).unwrap()
}

/// Unique name for a type.
///
/// All types are uniquely identified by a combination of their name and the module
/// in which they were declared; Since two types with the same name cannot be
/// declared in the same module, `TypeName` is always sufficient to disambiguate
/// between two types with the same name.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TypeName {
    /// The local name of the type.
    pub name: Cow<'static, str>,

    /// The path to the module where the type is declared, starting with the crate name.
    ///
    /// Note that this may not be the same module that the type is publicly exported
    /// from in the owning crate.
    pub module: Cow<'static, str>,
}

impl TypeName {
    pub fn new<N, M>(name: N, module: M) -> Self
    where
        N: Into<Cow<'static, str>>,
        M: Into<Cow<'static, str>>,
    {
        Self {
            name: name.into(),
            module: module.into(),
        }
    }
}
